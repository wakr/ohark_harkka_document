\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{rotating}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Ruby,                 % the language of the code
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
}


\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing



\title{Ruby on Rails -sovelluskehys; case: Translator}
\author{Kristian Wahlroos - 014417003}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
A.1 [Introductory and Survey],\\
I.7.m [Document and text processing]}}

\keywords{ulkoasu, lähdeluettelo}


\mytableofcontents

% PDF --> BIB --> PDF --> PDF -- VIEW

\section{Johdanto}
Tämän harjoitustyön tarkoituksena on tarkastella Ruby on Rails -web sovelluskehystä ja varsinkin sen arkkitehtuuria tekemäni esimerkkisovelluksen kautta. Tekemäni esimerkkisovellus on yksinkertainen Internetissä oleva käännössivusto, jonka avulla käyttäjä pystyy kääntämään kolmen eri kielen välillä; suomen, englannin ja ruotsin. Itse sivusto on erittäin yksinkertainen eikä toiminnallisuutta ole hirveästi kääntämisen lisäksi, vaan itse keskittyminen tapahtuu sovelluksen pinnan alle kuten arkkitehtuurisiin ratkaisuihin joita Ruby on Rail-kehys tuo mukanaan. 


\subsection{Translator -projekti}
Sovellukseneeni viittaan tästä alkaen nimellä \textit{Translator}. 

Translatorin pääidea on siis nimensä mukaisesta kääntää annettu teksti kieleltä toiselle. Käännöksen logiikka hoidetaan ulkopuolista API:a käyttäen \cite{yandex}, joka hoitaa käytännössä kääntämisen sovelluslogiikan. Seuraavassa esitettävä kuvasarja esittää kääntämisen käyttäjän näkökulmasta.

\vfill

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/ennen_kaannosta.png}}
\caption{Käyttäjä haluaa kääntää tämän lauseen suomesta englantiin. Osoite: /}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/kaannoksen_jalkeen.png}}
\caption{Uudelleenohjataan selain näyttämään tulos. Osoite: /translations/:id}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/kaikkien_listaus.png}}
\caption{Käyttäjä on navigoinut itsensä kaikkien käännöksien sivulle klikkaamalla linkkiä pääsivulla (linkki on tallennettujen käännöksien määrä). Osoite: /translations.}
\end{center}
\end{figure}

\vfill
\clearpage


Edellinen kuvasarja eteni siis käyttäjän selaimessa seuraavasti: 

Root (/)  $\rightarrow$ tallennettu käännös (/translations/:id, jossa :id korvautuu tietokantaan tallennetun tietueen id:llä) $\rightarrow$ root (/) $\rightarrow$ kaikki käännökset (/translations). 



\subsection{Ruby on Rails -sovelluskehys}
 
Ruby on Rails on itsessään sovelluskehys, joka on luotu vuonna 2003 David Heinemeier Hansson toimesta \cite{ror}. Sen näkyvimpiä ominaisuuksia ovat MVC-malli, REST-rajapinnat, Convention over Configuration- ja Don't Repeat Yourself-periaate. Nämä kaikki tulevat esille käytännössä kaikissa Ruby on Rails -kehyksellä tuotetuissa projekteissa ja moni tunteekin kehyksen juuri näistä edellä mainituista laatuvivuista, joita kehyksen käyttö melko automaattisesti tuo mukanaan. 

Yleisimpiä tyylejä ei sovelluskehyksestä suoraan löydy, koska usealla komponentilla ei suoraan löydy vastaavuutta muista tyyleistä MVC:n lisäksi (MVC lasketaan tässä enemmänkin patterniksi), koska niiden vastuut ovat hieman laajempia. Kuitenkin asiakas-palvelin -tyyli on melko selkeästi nähtävissä Ruby on Railsissä.  



\paragraph{Model-View-Controller -patterni}
Ruby on Rails:n Modelina toimii ActiveRecordin avulla käsiteltävät tietokantaobjektit. ActiveRecord huolehtii käytännössä koko toteutettavan järjestelmän logiikasta ja abstrahoi vahvan rajapinnan avulla konkreettista tietokantaa niin, että kehittäjän on esimerkiksi helppo vaihtaa tietokanta toiseen versioon sekä luoda uusia tietokantaobjekteja. 

ActiveRecord itsessään toteuttaa Active Record-patternin \cite{ar}, joka määrittelee, että miten luokat ja tietokanta kuvautuu toisillensa. Rubyssä tämä kuvautuminen on tehty niin, että tietokannan tietue on aina luokka ja taulut luokan kenttiä. Luokkien metodeilla usein muutetaankin vain ja ainoastaan tietokantataulun rivejä, jolloin olion sisäinen tila muuttuu. Luomassani projektissa uuden käännöksen ja sen tallentaminen tietokantaan on hyvin yksinkertaista tämän vuoksi, eikä kehittäjän tarvitse tietää, että taustalla pyörii SQLite tietokantana: 
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
t = Translation.new
***
kenttien alustus
***
t.save
\end{lstlisting}

ActiveRecordin avulla myös suorat tietokantakyselyt on abstrahoitu pois. Kyselyt toimivat aina luokan nimen kautta, jolloin esimerkiksi omassa sovelluksessani kaikki suomesta käännetyt käännökset löytyvät seuraavasti: 
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
Translation.all.where language_from: "fi"
\end{lstlisting}


Viewin vastuuta Ruby on Railsissä hoitaa ActionView, joka on näkymä tietokannan datalle. Kaikessa yksinkertaisuudessaan siis näytettävä HTML-sivu käyttäjälle. Se ladataan Controllerin toimesta oikeasta kansiosta oikealla hetkellä ja käytännössä se onkin HTML-tiedosto, joka sisältää upotettua Ruby-koodia. Tämä Ruby-koodi on suurimmaksi osaksi toiminnallisuutta näyttää vastaavan mallin tietoja HTML-muodossa. Esimerkiksi sovellukseni kaikki tehdyt käännökset näyttävä sivu on suurimmaksi osaksi upotettua Ruby-koodia, joka iteroi tietokannan kaikki käännökset ja hakee niiden tietokantataulut taulukkoon näytettäväksi dataksi. 

Controlleria kutsutaan ActionController:ksi Ruby on Railsissa ja se vastaa koko järjestelmään kohdistuvien pyyntöjen reitittämisestä sekä yleisestä datan välityksestä. Omassa järjestelmässäni TranslationController vastaa kaikesta käännöksiin liittyvästä toiminnallisuudesta, kuten esimerkiksi aloitussivun näyttämisen logiikasta. Railsissa konventiot tulevatkin vahvasti esille, koska Translation-luokasta vastaavan kontrollerin on oltava samanniminen kuin luokkakin, mutta monikossa (englannin s-päätteellä). Tähän kontrolleriin on myös kirjoitettu kaikki mahdolliset toiminnot, joita mallille on mahdollista tehdä ja näiden avulla rakennetaan myös näkymät.

\paragraph{REST-rajapinta}

Koko Ruby on Railsin käyttöönotto ja sen konventioiden noudattaminen tekee toteutettavasta järjestelmästä melkein automaattisesti REST-rajapintaa noudattavan järjestelmän, koska useat konventiot ovat pakollisia käyttää ja vaikka niiden kiertäminen on teknisesti mahdollista, on usein vain helpompi alistua valmiiksi määriteltyihin konventioihin. Esimerkiksi luodessani Translation-mallia, oli minun pakko luoda TranslationsController-kontrolleri, mutta ennen niiden linkittämistä on tiedostoon /config/routes.rb kerrottava, että mikä osoite linkittyy mihinkin kontrolleriin. Omassa projektissani olen lisännyt seuraavan rivin kyseiseen tiedostoon
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
resources :translations, only: [:show, :new, :create]
\end{lstlisting}

Tämän avulla olen saanut automaattisesti käyttöön seuraavat osoitteet:
\newline
\lstset{language=Ruby}  
\begin{lstlisting}  % Start your code-block
""
translations    POST /translations(.:format)     translations#create
new_translation GET  /translations/new(.:format) translations#new
translation     GET  /translations/:id(.:format) translations#show
\end{lstlisting}



\paragraph{Convention over Configuration}
%- kansiorakenne (app)
%- routes.rb
%- Gems
%- database.yml
%- migraatiot
%- nimeäminen
%- https://github.com/bbatsov/rails-style-guide
%- luokkien linkitys  (UML-style)

Konventiot ovat tärkeässä roolissa Ruby on Rails -sovelluskehyksessä. Ne suoraviivaistavat koko toteutettavan järjestelmän arkkitehtuuria, vähentävät ohjelmakoodin määrää, vähentävät toistoa ja tuovat yhtenäisen toimintatavan, jonka avulla jokainen Ruby on Rails:llä tuotettu järjestelmä on hyvin samankaltainen muiden samalla sovelluskehyksellä tuotettujen kanssa. Esimerkiksi nimeämiseen liittyvät konventiot (projektini tietokantataulussani 'translations' sijaitsevat kaikki Translation-mallin ilmentymät, kontrolleri nimeltä 'translations\_controller' huolehtii näiden mallien päivittämisestä sekä oikeiden näkymien näyttämisestä) ovat erittäin näkyvässä roolissa ja osittain jopa pakollisiakin.

Tämän avulla sovelluskehys osaa automaattisesti nimeämisten perusteella ohjata sovelluksen toimintaa haluttuun suuntaa, jolloin tarve konfiguraatio-tiedoistoille vähenee. Ruby on Rails siis pinnan alla automaattisesti päättelee nimien perusteella, että kenelle kyseiseen pyyntöön vastaamisen vastuu kuuluukaan.

\paragraph{Don't Repeat Yourself}

DRY-periaate näkyy vahvasti muun muassa Gemfile:n, routes.rb:n sekä tietokantamigraatioiden kautta. Gemfile-tiedostossa sijaitsee sovelluksen kaikki tarvitsemat Gem:it eli ulkoiset kirjastot, routes.rb-tiedosto taas sisältää kaikki määrittelyt pyyntöjen ohjaukseen oikealle kontrollerille ja tietokantamigraatioille on myös oma paikkansa 'db'-kansion alla. Migraatioiden avulla tehdään muutoksia tietokantaan ja sieltä nähdään kaikki aiemmin tehdyt muutokset ja niiden peruutukset ('rollbackit').

Toisaalta jo aiemmin mainittu ActiveRecord vähentää toistoa, koska kehittäjien ei tarvitse kirjoittaa erikseen ylös tietokantatauluja mallien määrittelytiedostoihin, vaan Ruby on Rails hoitaa kaiken tietokantalogiikan nimeämiskonventioiden avulla.

\subsection{Arkkitehtuuriset tyylit}

Kuten aiemmin mainittu, niin Ruby on Railsistä ei suoraan löydy juuri niinkään yhtä tiettyä tyyliä, jota kehys noudattaisi, mutta toisaalta 3-taso- malli on melko lähellä sitä. 

Vastuut ovat siinä jaettu niin, että esimerkiksi tarkasteltessa kehystä tavallisen 3-taso -arkkitehtuurityylin silmin, erottuu joitain melko erilaisiakin vastuita. Näkymätasolla tosin vastuu on aika selkeä: näkymistä huolehtivat HTML-tiedostot, mutta sovellustasosta huolehtii mallit sekä kontrollerit, jotka saavat pyyntöjä UI:lta (HTML/HTTP). Datataso Railsissä koostuu ActiveDirectorystä, tietokannasta sekä varsinkin malleista. Mallit siis kuuluvat periaatteessa sovellustason sekä datatason välimaastoon, koska toisaalta kaikki sovelluslogiikka sijaitsee niissä, mutta toisaalta ne toimivat myös abstraktiona tietokannan tauluille ja koko tietokannan muokkaus tapahtuu suoraan mallien kautta.


\paragraph{Asiakas-palvelin}

Kommunikointi kaikkien komponenttien välillä tapahtuu asiakas-palvelin- tyylin perusteella. Kontrollerit odottavat pyyntöjä näkymiltä ja tarjoavat tiedon näkymille mallien kautta. Mallit taas ovat suora linkki tietokantaan tehden muokkauksia sinne omaan tietokantatauluun sekä hakevat tietoa kontrollerien käyttöön. Ne tarjoavat kontrollereille muokkaus/haku-rajapinnan tietokantaan. Tämä kyseinen kommunikaatio tietokantatauluun tapahtuu aina ActiveDirectoryn kautta, joka muuttaa pyynnöt kyseisen tietokannan osaamalle kielelle (usein SQL).

% RubyCommunication.png 

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/RubyCommunication.png}}
\caption{Havainnekuva kommunikaatiosta.}
\end{center}
\end{figure}

\newpage

\section{Yleisarkkitehtuuri ja keskeisimmät variaatiopisteet}
%Roolijako here (N-tier + 
% http://www.tutorialspoint.com/ruby-on-rails/images/rails-framework.gif)
% http://adrianmejia.com/blog/2011/08/11/ruby-on-rails-architectural-design/
Ruby on Rails toteuttaa yleiseltä arkkitehtuuriltaan erittäin vahvasti jo aiemmin mainittua Model View Controller -tyyliä, mutta kehystä voidaan tarkastella myös perinteisemmän 3-taso -tyylin kautta. 

Siinä vastuidenjako on selvästi jaettuna kolmeen eri kerrokseen: tiedon tallennukseen, käsittelyyn sekä näyttämiseen. Tallennuksesta vastaa yhdessä tietokanta sekä Railsin ActiveDirectory-toteutus. Tieto itsessään käsitellään kontrollereiden tasolla, jossa tapahtuu myös mallien muokkaus ja lopullinen UI-muotoinen tiedon esitys tapahtuu HTML-tiedostojen avulla. Kerroksia ei pysty mitenkään ohittamaan, jolloin datan tallennus suoraan näkymästä on esimerkiksi käytännössä mahdotonta.

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=0.75\textwidth]{images/RubyOnRailsOverArch.png}}
\caption{Yksinkertaistettu arkkitehtuuri Translator-sovelluksesta 3-tasoisena tarkasteltaessa. Datan virtaus kuvattu nuolilla. Alin taso huolehtii tiedon tallennuksesta, keskimmäinen tiedon käsittelystä ja ylin tiedon näyttämisestä.}
\end{center}
\end{figure}

MVC-mallisena tarkasteltaessa Ruby on Rails -sovelluskehys näyttää seuraavanlaiselta:

\begin{figure}[H]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/RoRMVC.png}}
\caption{Translator-sovellus MVC-mallin silmin. Kuvassa käyttäjä avaa selaimensa '/translations'-osoitteeseen, joka reititetään oikealle kontrollerin metodille (index) routes.rb-tiedoston avulla. Kontrolleri hakee kaikki Translation-mallin ilmentymät mallin avulla tietokannasta. @translations sekä @languages muuttujat välitetään näkymälle, joka luo halutun HTML-tiedoston. Lopuksi kontrolleri esittää (render) tämän dokumentin käyttäjän selaimelle.}
\end{center}
\end{figure}

\paragraph{Sisärakennemalli}
Seuraavassa Translator-järjestelmän komponentit.
\begin{figure}[H]
\begin{center}
\fbox{\includegraphics[width=1.1\textwidth, height=0.7\textheight]{images/RorSisarakenne.png}}
\caption{Yhtenäinen viiva tarkoittaa web-pyyntöä ja katkonainen tietokantayhteyttä. Muut viivat komponenttien välisiä funktiokutsuja, joiden sisältö <<>>-välissä.}
\end{center}
\end{figure}

Edellisestä kuvasta erottuu kaksi isoa järjestelmää, josta toinen on Translator-sovellukseni ja toinen Yandex-API, joka huolehtii kääntämisen logiikasta. Translator-sovelluksesta voidaan erotella seuraavat Ruby on Rails -kehyksen kannalta pakolliset komponentit.

\subparagraph{Web-palvelin}
Oletuksena WEBrick Ruby on Rails -kehyksessä \cite{webrick}. Tarjoaa yksinkertaisen HTTP-palvelimen toiminnallisuuden. Voidaan helposti korvata esimerkiksi Apache tai Puma-palvelimella \cite{rubyserver}, sekä usealla muulla sovelluskehyksen tukemalla. 

\subparagraph{Action Pack}
Tarjoaa kontrolleri- ja näkymäkerroksen Model-View-Controller-patternille. Tässä sijaitsevat komponentit käsittelevät selaimen pyynnöt ja reitittävät pyynnöt oikeille komponenteille jatkokäsittelyä varten, mutta myös vastaavat näkymän toteuttamisesta. Action Pack jakautuu kolmeen eri rajapintaan: Action Dispatch, Action Controller ja Action View.

\subparagraph{Action Dispatch}
Hoitaa selaimelta tulevien HTTP-pyyntöjen reitittämisen oikealle kontrollerille sekä niiden jäsentelyn. Suurin osa toiminnallisuudesta on määritelty routes.rb-konfiguraatiotiedostoon.

\subparagraph{Action Controller}
Määrittelee kontrollereiden perustoiminnallisuuden, jota voidaan periyttämällä erikoistaa. Toiminnallisuus koostuu näkymiä ja malleja varten tehdyistä operaatioista. Esimerkiksi datan saaminen näkymälle asti sekä uudelleenohjauksen toiminnallisuuden. 

\subparagraph{Action View}
Tulee kutsutuksi Action Controllerin kautta. Muodostaa halutun näkymän www-sivustosta käyttäjälle käyttäen hyödykseen erilaisia apukeinoja (esimerkiksi lomakkeiden ja linkkien muodostamiseen), templaatteja sekä hyvin usein RHTML-muotoa. RHTML on muodostettua HTML-koodia, jossa on upotettua ruby-koodia seassa, joka sitten korvautuu täysin HTML-muotoon juuri ennen lopullista esittämistä \cite{rhtml}.   

\subparagraph{Active Model}
Määrittelee rajapinnan edellä mainitun Action Pack-kokonaisuuden sekä Active Recordin välillä. 

\subparagraph{Active Record}
Huolehtii datan muokkauksesta objektien kautta ja tarjoaa CRUD-rajapinnan tietokantaan (Create Read Update Delete). Jokainen operaatio tapahtuu aina luokan kautta, jolle löytyy vastaavuus tietokannassa. Luottaa paljon nimeämis-konventioihin muualla sovelluksessa, jolloin erinäisiä konfiguraatiotiedostoja ei tarvita. 

\subsection{Kehyksen erikoistaminen sovelluskohtaisesti}
On huomattavaa, että esimerkiksi tietokanta ei sisälly järjestelmän sisälle, vaan ulkopuolelle ja on näin helposti vaihdettavissa. Tämä on toteutettu aiemmin mainitun ActiveRecordin avulla. Myös näkymien vaihdettavuus on erittäin helppoa, koska Ruby on Rails-konventioiden mukaan vain nimeämisellä (ja kansiorakenteella) on väliä, joten kunhan tiedostot sijaitsevat oikeissa kansioissa oikeilla nimillä, niin esimerkiksi näkymät saadaan vaihdettua muuttamalla vain tiedoston nimeä. 

Toisaalta laajemmin ajateltuna ainoaksi yhteiseksi osaksi (variaatiopisteiden kannalta) jää malli, koska se on ainut osa, joka toteuttaa itse business-logiikan ja toimii abstraktiona tosimaailman käännöksen käsitteelle. Tätä ei pysty mitenkään muuttamaan, koska haluan sovelluksen nimenomaan olevan käännös-toimintoa tukeva sivusto, joka pystyy tallentamaan aiemmin tehtyjä käännöksiä. Tämän vuoksi tallenuslogiikalla, näkymillä, eikä ohjainkomponenteille ole kovinkaan tärkeää roolia järjestelmässä ja tästä syystä ne voidaan laskea vaihtuviksi osiksi variaation kannalta Ruby on Rails-kehyksessä. 

Kuvassa 7. olen merkannut kuvaan järjestelmän sisälle tummennettuna ne komponentit, joihin olen tehnyt itse muutoksia. Kuitenkin ':TranslationsController', ':views' ja ':Translation' ovat perittyjä jostain tai toteuttavat jonkun rajapinnan, jolloin niiden toiminnallisuus on suhteellisen rajoitettu ja ennalta määritelty. Ainoastaan ':TranslatorApi' on täysin itsenäinen oma staattinen luokkansa, jota ':Translation' käyttää hyväkseen muodostaessaan kyselyitä ulkopuoliseen Yandex-APIin. 

\subsection{Sekvenssikaavio}
Seuraavassa kuvataan sekvenssikaavion avulla miten uuden käännöksen tekeminen tapahtuu järjestelmässä ja miten se tallentuu tietokantaan. Kuvassa käyttäjä on navigoinut itsensä sivulle etusivule ('/'-osoitteeseen). Hän kirjoittaa lomakkeeseen haluamansa tekstin, valitsee kielen ja painaa 'Translate!' (Kuva 1). Sekvenssikaavio alkaa tästä tapahtumasta, mutta siinä on abstrahoitu joitan osia pois (funktiokutsuja) pääosin sen takia, että kuvaa olisi helpompi tulkita.

\begin{sidewaysfigure}
    \centering
    \includegraphics[width=1.05\textwidth]{images/sekvenssi.png}
    \caption{Sekvenssikaavio käännöksen tekemisestä ja tallentamisesta.}
    \label{fig:awesome_image}
\end{sidewaysfigure}

\newpage


\section{Kehyksen ja sovelluksen arviointi}

Sovelluskehyksenä Ruby on Rails on erittäin tarkka sen omista käytänneistä, kun sitä verrataan esimerkiksi toiseen erittäin suosittuun backend-sovelluskehykseen NodeJS:ään. NodeJS tarjoaa samalla tavalla kehyksen tuottaa web-palveluita, mutta se on rakenteellisesti paljon kevyempi ja vähemmän rajoittava. Toisaalta Ruby on Rails sopii hyvin aloitteleville ohjelmoijille sekä pienehköille start-up -henkisille yrityksille juuri sen käytänteiden vuoksi. Niitä noudattamalla pystytään todella nopeasti kehittämään palveluita asiakkaille.

Kuitenkin muutama heikkous kehyksessä nousee esille. Näitä ovat muun muassa suoritusteho, sovelluksen saaminen verkkoon, legacy-järjestelmän kanssa kommunikointi sekä sovelluskehyksen tuoma rajoittuneisuus \cite{rorad}.


\paragraph{Sopiiko suunniteltu arkkitehtuuri järjestelmälle?}

Kehys ja kehyksestä johdettu MVC-mallinen arkkitehtuuri sopii todella hyvin tekemälleni järjestelmälle. Se on todella helposti muokattavissa sekä erilaisten näkymien/tietokannan vaihtaminen onnistuu hyvinkin nopeasti. 

Suurimmat laadulliset vaatimukset järjestelmälleni olivat alussa, että se on nopea saada pystyyn, nopeaa kehittää ja monipuolinen jatkon kannalta. Sovelluskehys tarjosi mielestäni nämä kaikki ja sivussa tuli muutama laatuvipukin. 

\subsection{Hyvät ja huonot puolet}

Hyvät puolet kehyksessä ovat selkeästi kehittämisen nopeus sekä konventioiden tuoma järjestelmien virtaviivaistaminen, kun taas huonot puolet tulevat suurimmalta osin konventioiden pakollisuudesta sekä Ruby-kielestä.

\subsubsection{Hyvät puolet}

Kehyksen hyvät puolet tulevat melkein automaattisesti noudattamalla jopa toisinaan tiukkoja Railsin konventioita. Hyviin puoliin lukeutuvat muun muassa konventioiden kautta tuleva REST-rajapinta; nopea kehitys, joka sopii hyvin Agile-projekteihin; konventiot itsessään, jotka auttavat kehittäjiä siirtymään helposti Rails projektien välillä; kielenä Rubyn itsedokumentoiva tyyli sekä useimmat kehykseen liitettävät ulkopuoliset kirjastot ovat suurimmalta osin avointa lähdekoodia \cite{bitzesty}.

Rails on tullut suosituksi myös startup-yrityksissä. Tähän on ollut syynä pääosin kehyksen: koventiot, kehys on käytännössä ilmainen kirjastoja myöten, erittäin hyvä PaaS-tuki (Platform as a Service), gem-ideologia (riippuvuudet yhdessä tiedostossa ja niiden helppo hallinta) sekä Rails on alustana kasvava ja reagoi uusiin tarpeisiin web-ympäristössä jatkuvasti \cite{wsuror}. 


\subsubsection{Huonot puolet}


\paragraph{Suoritustehon heikkous} 

Ruby on itsessään tulkattava kieli, joten suoritusteholtaan se häviää käännettäville kielille esimerkkinä Java Spring. Toisaalta Ruby on Rails-kehyksen teho tulee tuottavuuden nopeudesta, mutta tuottavuus ei ratkaise yhtä Railsin suurinta ongelmaa; erittäin huonoa tukea säikeistämiselle. Tämä tuottaa paljon ongelmia, jos järjestelmän yhtäaikaiset käyttäjämäärät kasvavat suuriksi, koska säikeistämisen avulla ei pystytä tasapainottamaan syntynyttä kuormaa (load balance). Täten Ruby on Rails soveltuu melko huonosti sovelluksille, jossa nopeus on oltava suuri käyttäjämäärien ollessa myös suuria. Skaalautuuvus on myös tuottanut paljon puheita sekä puolesta, että vastaan \cite{rorsca}.

\paragraph{Sovelluksen vaikea tuotantoo saattaminen} 

Rails-kehys vaatii paljon esiasennusta, koska esimerkiksi tavallisissa Linux-jakeluissa ei edes ole Ruby-kirjastoa valmiina. Tämän päälle pitää asentaa itse kehys ja se vie suhteellisen paljon enemmän tilaa ja aikaa, kuin muut paljon kevyemmät kehykset \cite{bitzesty}. Tästä johtuu suhteellisen huono palvelimien tuki Ruby on Rails-kehykselle ja aikaa saa kulumaan palvelimen säätämisessä Railsia varten. 

\paragraph{Rajoittuneisuus}

Rails painottaa sisäisesti eleganttia syntaksia, tuotteliaisuutta sekä ylläpidettävyyttä nopeuden ja resurssien hallinan kustannuksella. Nämä on toteutettu suurimallta osin konventioiden avulla, joten kehys saattaa tuntua kehittäjille todella rajoittavalta. Vaikka konventioista voi poiketa, niin jokainen poikkeama mahdollistaa potentiaalisen virheen myöhemmin järjestelmän elinkaaressa. Konventiot myös rajoittavat legacy-järjestelmien kanssa toimimista ja varsinkin legacy-tietokannan kanssa työskentely vaatii kehyksessä jopa todella paljon konfigurointia \cite{rorlegacy}.



\subsection{ATAM-arviointi}
 pienehkö joukko (laatu-) skenaarioita jonkin laatuominaisuuden testaamiseksi - sekä odotettavissa olevia että järjestelmän rajoja määritteleviä (katso luentokurssin materiaalit arkkitehtuurin arvioinnista ja ATAM:sta) 

Esitetään konkreettisia
esimerkkitilanteita, joissa tietyt
laatuominaisuudet tulevat esiin

\paragraph{Laatuominaisuuden testaaminen - muunneltavuus ja uudelleenkäytettävyys}
 (saatavuus/muunneltavuus/uudelleenkäyt.)
Arkkitehtuurin arvioiminen
Low/Medium/High (vaativuus + työmäärä)

Jos tarkastellaan muutettavuutta, skenaario käsittelee jotakin
muutostarvetta järjestelmän evoluutiossa

Jos tarkastellaan uudelleenkäytettävyyttä, skenaario käsittelee
jonkin uuden sovelluksen tekemistä uudelleen käyttämällä
järjestelmää (= tuoterunko)

(.json-rajapinta)

Laatupuu

Identifioidaan riskit, turvalliset ratkaisut, herkkyyskohdat ja tasapainottelukohdat.


\newpage
\cleardoublepage
%
% Sitten alkaa lähdeluettelo
%


\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

\end{document}
