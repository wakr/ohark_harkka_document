\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{rotating}

\usepackage[T1]{fontenc}
\usepackage{lmodern}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Ruby,                 % the language of the code
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
}


\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing



\title{Ruby on Rails -sovelluskehys; case: Translator}
\author{Kristian Wahlroos - 014417003}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
A.1 [Introductory and Survey],\\
I.7.m [Document and text processing]}}

\keywords{ulkoasu, lähdeluettelo}


\mytableofcontents

% PDF --> BIB --> PDF --> PDF -- VIEW

\section{Johdanto}
Tämän harjoitustyön tarkoituksena on tarkastella Ruby on Rails -web sovelluskehystä ja varsinkin sen arkkitehtuuria tekemäni esimerkkisovelluksen kautta. Tekemäni esimerkkisovellus on yksinkertainen Internetissä oleva käännössivusto, jonka avulla käyttäjä pystyy kääntämään kolmen eri kielen välillä; suomen, englannin ja ruotsin. Itse sivusto on erittäin yksinkertainen eikä toiminnallisuutta ole hirveästi kääntämisen lisäksi. Raportin keskittyminen tapahtuukin sovelluksen pinnan alle kuten arkkitehtuurisiin ratkaisuihin joita Ruby on Rail-kehys tuo mukanaan. 


\subsection{Translator -projekti}
Sovellukseneeni viittaan tästä alkaen nimellä \textit{Translator}. 

Translatorin pääidea on siis nimensä mukaisesta kääntää annettu teksti kieleltä toiselle. Käännöksen logiikka hoidetaan ulkopuolista API:a käyttäen \cite{yandex}, joka hoitaa käytännössä kääntämisen sovelluslogiikan. Seuraavassa esitettävä kuvasarja esittää kääntämisen käyttäjän näkökulmasta:

\vfill

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/ennen_kaannosta.png}}
\caption{Käyttäjä haluaa kääntää lauseen suomesta englantiin. Osoite: /}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/kaannoksen_jalkeen.png}}
\caption{Uudelleenohjataan selain näyttämään tulos. Osoite: /translations/:id}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/kaikkien_listaus.png}}
\caption{Käyttäjä on navigoinut itsensä kaikkien käännöksien sivulle klikkaamalla linkkiä pääsivulla (linkki on tallennettujen käännöksien määrä). Osoite: /translations.}
\end{center}
\end{figure}

\vfill
\clearpage


Edellinen kuvasarja eteni siis käyttäjän selaimessa seuraavasti: 

Pääsivu (/)  $\rightarrow$ tallennettu käännös (/translations/:id, jossa :id korvautuu tietokantaan tallennetun tietueen id:llä) $\rightarrow$ pääsivu (/) $\rightarrow$ kaikki käännökset (/translations). 



\subsection{Ruby on Rails -sovelluskehys}
 
Ruby on Rails on itsessään sovelluskehys, joka on luotu vuonna 2003 David Heinemeier Hansson toimesta \cite{ror}. Sen keskeisimpiä ominaisuuksia ovat MVC-malli, REST-rajapinnat, Convention over Configuration- ja Don't Repeat Yourself-periaate. Nämä kaikki tulevat esille käytännössä kaikissa Ruby on Rails -kehyksellä tuotetuissa projekteissa ja moni tunteekin kehyksen juuri näistä edellä mainituista laatuvivuista, joita kehyksen käyttö melko automaattisesti tuo mukanaan. 

Yleisimpiä arkkitehtuurisia tyylejä ei sovelluskehyksestä suoraan löydy, koska kehys on sidottu lujasti MVC-patterniin. Kuitenkin asiakas-palvelin -tyyli on melko selkeästi nähtävissä Ruby on Railsissä.  



\paragraph{Model-View-Controller -patterni}
Ruby on Rails:n Modelina toimii ActiveRecordin avulla käsiteltävät tietokantaobjektit. ActiveRecord huolehtii käytännössä koko toteutettavan järjestelmän logiikasta ja abstrahoi vahvan rajapinnan avulla konkreettista tietokantaa niin, että kehittäjän on esimerkiksi helppo vaihtaa tietokanta toiseen versioon sekä luoda uusia tietokantaobjekteja. 

Kehyksen ActiveRecord itsessään toteuttaa Active Record-patternin \cite{ar}, joka määrittelee, että miten luokat ja tietokanta kuvautuu toisillensa. Railsissa tämä kuvautuminen on tehty niin, että tietokannan tietue on aina luokka ja taulut luokan kenttiä. Luokkien metodeilla usein muutetaankin vain ja ainoastaan tietokantataulun rivejä, jolloin olion sisäinen tila muuttuu. Luomassani projektissa uuden käännöksen luominen ja sen tallentaminen tietokantaan on hyvin yksinkertaista tämän vuoksi, eikä kehittäjän tarvitse tietää, että taustalla pyörii SQLite tietokantana: 
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
t = Translation.new
***
kenttien alustus
***
t.save
\end{lstlisting}
\newpage

ActiveRecordin avulla myös suorat tietokantakyselyt on abstrahoitu pois. Kyselyt toimivat aina luokan nimen kautta, jolloin esimerkiksi omassa sovelluksessani kaikki suomesta käännetyt käännökset löytyvät seuraavasti: 
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
Translation.all.where language_from: "fi"
\end{lstlisting}


Viewin vastuuta Ruby on Railsissä hoitaa ActionView, joka on näkymä tietokannan datalle. Kaikessa yksinkertaisuudessaan siis näytettävä HTML-sivu käyttäjälle. Se ladataan kontrollerin toimesta oikeasta kansiosta oikealla hetkellä ja käytännössä se onkin HTML-tiedosto, joka sisältää upotettua Ruby-koodia. Tämä Ruby-koodi on suurimmaksi osaksi toiminnallisuutta näyttää mallin tietoja HTML-muodossa. Esimerkiksi sovellukseni kaikki tehdyt käännökset näyttävä sivu on suurimmaksi osaksi upotettua Ruby-koodia, joka iteroi tietokannan kaikki käännökset ja hakee niiden tietokantataulut taulukkoon näytettäväksi dataksi. 

Controlleria kutsutaan ActionControlleriksi Ruby on Railsissa ja se vastaa koko järjestelmään kohdistuvien pyyntöjen reitittämisestä sekä yleisestä datan välityksestä. Omassa järjestelmässäni TranslationsController vastaa kaikesta käännöksiin liittyvästä toiminnallisuudesta, kuten esimerkiksi aloitussivun näyttämisen logiikasta. 

\paragraph{REST-rajapinta}

Koko Ruby on Railsin käyttöönotto ja sen konventioiden noudattaminen tekee toteutettavasta järjestelmästä melkein automaattisesti REST-rajapintaa noudattavan järjestelmän, koska useat konventiot ovat pakollisia käyttää ja vaikka niiden kiertäminen on teknisesti mahdollista, on usein vain helpompi alistua valmiiksi määriteltyihin konventioihin. Esimerkiksi luodessani Translation-mallia, oli minun pakko luoda TranslationsController-kontrolleri, mutta ennen niiden linkittämistä on tiedostoon /config/routes.rb kerrottava, että mikä osoite linkittyy mihinkin kontrolleriin. Omassa projektissani olen lisännyt seuraavan rivin kyseiseen tiedostoon:
\newline
\lstset{language=Ruby}  
\begin{lstlisting}[frame=single]  % Start your code-block
""
resources :translations, only: [:show, :new, :create]
\end{lstlisting}

Tämän avulla olen automaattisesti saanut käyttöön seuraavat osoitteet, jotka noudattavat REST-tyyliä:
\newline
\lstset{language=Ruby}  
\begin{lstlisting}  % Start your code-block
""
translations    POST /translations(.:format)     translations#create
new_translation GET  /translations/new(.:format) translations#new
translation     GET  /translations/:id(.:format) translations#show
\end{lstlisting}



\paragraph{Convention over Configuration}
Railsissa konventiot tulevat vahvasti esille, koska esimerkiksi Translator-projektin Translation-luokasta vastaavan kontrollerin on oltava samanniminen kuin luokkakin, mutta monikossa (englannin s-päätteellä). Tähän kontrolleriin on myös kirjoitettu kaikki mahdolliset toiminnot, joita mallille on mahdollista tehdä ja näiden avulla rakennetaan myös toimintoja vastaavat näkymät.

Konventiot ovatkin yksi keskeisimmistä osista Ruby on Rails -sovelluskehyksessä. Ne suoraviivaistavat koko toteutettavan järjestelmän arkkitehtuuria, vähentävät ohjelmakoodin määrää, vähentävät toistoa ja tuovat yhtenäisen toimintatavan, jonka avulla jokainen Ruby on Railsilla tuotettu järjestelmä on hyvin samankaltainen muiden Rails-sovelluskehyksellä tuotettujen kanssa. Esimerkiksi nimeämiseen liittyvät konventiot ovat erittäin näkyvässä roolissa ja osittain jopa pakollisiakin \cite{rornc}. Nimeämiset näkyvät projektissani esimerkiksi, että projektini tietokantataulussani 'translations' sijaitsevat kaikki Translation-mallin ilmentymät, kontrolleri nimeltä 'TranslationsController' huolehtii näiden mallien päivittämisestä sekä oikeiden näkymien näyttämisestä. 

Nimeämiskonvention avulla sovelluskehys osaa automaattisesti ohjata sovelluksen toimintaa haluttuun suuntaan, jolloin tarve monimutkaisille konfiguraatio-tiedoistoille vähenee. Ruby on Rails siis pinnan alla automaattisesti päättelee nimien perusteella, että kenen vastuulle tiettyyn pyyntöön vastaamisen kuuluukaan.

\paragraph{Don't Repeat Yourself}

DRY-periaate näkyy vahvasti muun muassa Gemfile:n, routes.rb:n sekä tietokantamigraatioiden kautta. Gemfile-tiedostossa sijaitsee sovelluksen kaikki tarvitsemat Gem:it eli ulkoiset kirjastot, routes.rb-tiedosto taas sisältää kaikki määrittelyt pyyntöjen ohjaukseen oikealle kontrollerille ja tietokantamigraatioille on myös oma paikkansa 'db'-kansion alla. Migraatioiden avulla tehdään muutoksia tietokantaan ja sieltä nähdään kaikki aiemmin tehdyt muutokset ja niiden peruutukset ('rollbackit'). Nämä tiedostot vähentävät turhaa määrittelyä ulkopuolisiin luokkiin, jolloin konfiguraatiot sijaitsevat aina yhdessä paikassa. 

Toisaalta jo aiemmin mainittu ActiveRecord vähentää myös toistoa, koska kehittäjien ei tarvitse kirjoittaa erikseen ylös tietokantatauluja mallien määrittelytiedostoihin, vaan Ruby on Rails hoitaa kaiken tietokantalogiikan nimeämiskonventioiden avulla. Konventiot yleisestikkin vähentävät koodin määrää, joka taas mahdollistaa monimutkaisten asioiden tekemisen vain muutamalla rivillä ohjelmakoodia.

\subsection{Arkkitehtuuriset tyylit}

Ruby on Railsistä ei suoraan löydy juuri niinkään yhtä tiettyä tyyliä, jota kehys noudattaisi, mutta kehystä voidaan tarkastella 3-taso -ja asiakas-palvelin -mallin kautta.

\paragraph{3-taso -malli}
Vastuut ovat kolmitasoisena tarkasteltuna jaettu niin, että näkymätasosta huolehtivat HTML-tiedostot, sovellustasosta huolehtivat mallit sekä kontrollerit. Kontrollerit saavat pyyntöjä UI:lta 
(HTML/HTTP) ja niissä tapahtuu mallien muokkaus. Datataso Railsissä koostuu ActiveDirectorystä, tietokannasta sekä varsinkin malleista. Mallit siis kuuluvat periaatteessa sovellustason sekä datatason välimaastoon, koska toisaalta kaikki sovelluslogiikka sijaitsee niissä, mutta toisaalta ne toimivat abstraktiona tietokannan tauluille ja koko tietokannan muokkaus tapahtuu suoraan mallien kautta. 

Itse kerroksia ei pysty mitenkään ohittamaan, jolloin datan tallennus suoraan näkymästä on esimerkiksi käytännössä mahdotonta. Seuraavassa kuvassa on havainnollistettu tekemäni järjestelmää 3-taso -mallin avulla, josta nähdään tämä kyseinen rajoite.

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=0.75\textwidth]{images/RubyOnRailsOverArch.png}}
\caption{Yksinkertaistettu arkkitehtuuri Translator-sovelluksesta 3-tasoisena tarkasteltaessa. Datan virtaus kuvattu nuolilla. Alin taso huolehtii tiedon tallennuksesta, keskimmäinen tiedon käsittelystä ja ylin tiedon näyttämisestä.}
\end{center}
\end{figure}


\paragraph{Asiakas-palvelin}

Kommunikointi kaikkien komponenttien välillä tapahtuu asiakas-palvelin- tyylin perusteella. Kontrollerit odottavat pyyntöjä näkymiltä ja tarjoavat tiedon näkymille mallien kautta. Mallit taas ovat suora linkki tietokantaan tehden muokkauksia sinne mallia vastaavaan tietokantatauluun. Mallit hakevat myös tietoa kontrollerien käyttöön ja täten tarjoavat kontrollereille muokkaus/haku-rajapinnan tietokantaan. Tämä kyseinen kommunikaatio tietokantatauluun tapahtuu aina ActiveDirectoryn kautta, joka muuttaa pyynnöt kyseisen tietokannan osaamalle kielelle (usein SQL).

% RubyCommunication.png 

\begin{figure}[ht]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/RubyCommunication.png}}
\caption{Havainnekuva kommunikaatiosta.}
\end{center}
\end{figure}

\newpage

\section{Yleisarkkitehtuuri ja keskeisimmät variaatiopisteet}
Ruby on Rails toteuttaa yleiseltä arkkitehtuuriltaan erittäin vahvasti jo aiemmin mainittua Model View Controller -tyyliä ja todella moni kehyksellä tehdyistä sovelluksista onkin arkkitehtuuriltansa MVC-mallinen. MVC-mallisena tarkasteltaessa Ruby on Rails -sovelluskehys näyttää seuraavanlaiselta:

\begin{figure}[H]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/RoRMVC.png}}
\caption{Translator-sovellus MVC-mallin silmin. Kuvassa käyttäjä avaa selaimensa '/translations'-osoitteeseen, joka reititetään oikealle kontrollerin metodille (index) routes.rb-tiedoston avulla. Kontrolleri hakee kaikki Translation-mallin ilmentymät mallin avulla tietokannasta. @translations sekä @languages muuttujat välitetään tämän jälkeen näkymälle, joka luo halutun HTML-tiedoston. Lopuksi kontrolleri palauttaa tämän dokumentin käyttäjän selaimelle.}
\end{center}
\end{figure}

\paragraph{Sisärakennemalli}
Seuraavassa tarkastellaan Translator-järjestelmää komponenteittain, josta erottuu kaksi isoa järjestelmää. Toinen on Translator-sovellukseni ja toinen Yandex-API, joka huolehtii kääntämisen logiikasta. Näiden järjestelmien välisestä kommunikaatiosta huolehtii TranslatorApi-komponentti, joka muodostaa tarvittavat HTTP-pyynnöt ja palauttaa niiden tuloksen Translation-mallille sellaisessa muodossa, että se pystytään välittämään järkevässä muodossa eteenpäin.

\begin{figure}[H]
\begin{center}
\fbox{\includegraphics[width=1.1\textwidth, height=0.7\textheight]{images/RorSisarakenne.png}}
\caption{Yhtenäinen viiva tarkoittaa web-pyyntöä ja katkonainen tietokantayhteyttä. Muut viivat komponenttien välisiä funktiokutsuja, joiden sisältö <<>>-välissä.}
\end{center}
\end{figure}

Translator-sovelluksesta voidaan erotella seuraavat Ruby on Rails -kehyksen kannalta pakolliset komponentit, jotka mahdollistavat pohjatoiminnallisuuden koko järjestelmälle. Osa näistä ei näy kehittäjälle välttämättä ollenkaan, jolloin kehittäjä voi keskittyä vain oman järjestelmänsä kannalta relevantteihin asioihin. 

\subparagraph{Web-palvelin}
Oletuksena WEBrick Ruby on Rails -kehyksessä \cite{webrick}. Tarjoaa yksinkertaisen HTTP-palvelimen toiminnallisuuden. Voidaan helposti korvata esimerkiksi Apache tai Puma-palvelimella \cite{rubyserver}, sekä usealla muulla sovelluskehyksen tukemalla. 

\subparagraph{Action Pack}
Tarjoaa kontrolleri- ja näkymäkerroksen Model-View-Controller-patternille. Tässä sijaitsevat komponentit käsittelevät selaimen pyynnöt ja reitittävät pyynnöt oikeille komponenteille jatkokäsittelyä varten, mutta myös vastaavat näkymän toteuttamisesta. Action Pack jakautuu kolmeen eri rajapintaan: Action Dispatch, Action Controller ja Action View.

\subparagraph{Action Dispatch}
Hoitaa selaimelta tulevien HTTP-pyyntöjen reitittämisen oikealle kontrollerille sekä niiden jäsentelyn. Suurin osa toiminnallisuudesta on määritelty routes.rb-konfiguraatiotiedostoon.

\subparagraph{Action Controller}
Määrittelee kontrollereiden perustoiminnallisuuden, jota voidaan periyttämällä erikoistaa. Toiminnallisuus koostuu näkymiä ja malleja varten tehdyistä operaatioista. Esimerkiksi datan saaminen näkymälle asti sekä uudelleenohjauksen toiminnallisuuden. 

\subparagraph{Action View}
Tulee kutsutuksi Action Controllerin kautta. Muodostaa halutun näkymän www-sivustosta käyttäjälle käyttäen hyödykseen erilaisia apukeinoja (esimerkiksi lomakkeiden ja linkkien muodostamiseen), templaatteja sekä hyvin usein RHTML-muotoa. RHTML on muodostettua HTML-koodia, jossa on upotettua ruby-koodia seassa, joka sitten korvautuu täysin HTML-muotoon juuri ennen lopullista esittämistä \cite{rhtml}.   

\subparagraph{Active Model}
Määrittelee rajapinnan edellä mainitun Action Pack-kokonaisuuden sekä Active Recordin välillä. Kaikki mallit, jotka haluavat toimia tietokannan kautta toteuttavat tämän rajapinnan.

\subparagraph{Active Record}
Huolehtii datan muokkauksesta objektien kautta ja tarjoaa CRUD-rajapinnan (Create Read Update Delete) tietokantaan. Jokainen operaatio tapahtuu aina luokan kautta, jolle löytyy vastaavuus tietokannassa. ActiveRecord luottaa paljon nimeämiskonventioihin muualla sovelluksessa, jolloin erinäisiä konfiguraatiotiedostoja ei tarvita. 

\subsection{Ohjelmistotason suunnittelumallit}
Rakentamassani järjestelmässä ei ole tarkoituksella käytetty mitään tiettyä ohjelmistotason sunnittelumallia, mutta itse Rails-kehyskään ei sisäisesti toteuta raportin alussa mainittujen lisäksi muita, koska iso osa joustavuudesta tulee jo itse Ruby kielestä ja sen ominaisuuksista. Toisaalta kuitenkin ActiveRecord toteuttaa Object-relational mapping -mallia piilottaessaan tietokantakyselyt luokkien taakse, mutta tämän lisäksi ei muita ohjelmistotason suunnittelumalleja löydy. 

\subsection{Kehyksen erikoistaminen sovelluskohtaisesti}
On huomattavaa, että esimerkiksi tietokanta ei sisälly järjestelmän sisälle, vaan ulkopuolelle ja on näin helposti vaihdettavissa. Tämä on toteutettu aiemmin mainitun ActiveRecordin avulla. Näkymien vaihdettavuus on erittäin helppoa, koska Ruby on Rails-konventioiden mukaan vain nimeämisellä (ja kansiorakenteella) on väliä, joten kunhan tiedostot sijaitsevat oikeissa kansioissa oikeilla nimillä, niin esimerkiksi näkymät saadaan vaihdettua muuttamalla vain tiedoston nimeä. 

Toisaalta laajemmin ajateltuna ainoaksi yhteiseksi osaksi variaatiopisteiden kannalta jää malli, koska se on ainut osa, joka toteuttaa itse business-logiikan ja toimii abstraktiona tosimaailman käännöksen käsitteelle. Järjestelmässäni Translation-malli on hyvin sidottu, koska haluan sovelluksen nimenomaan olevan käännös-toimintoa tukeva sivusto, joka pystyy tallentamaan aiemmin tehtyjä käännöksiä. Tämän vuoksi tallenuslogiikalla, näkymillä, eikä ohjainkomponenteille ole kovinkaan tärkeää roolia järjestelmässä ja tästä syystä ne voidaan laskea vaihtuviksi osiksi variaation kannalta Ruby on Rails-kehyksessä. 

Itse kehyksen erikoistaminen tapahtuu pääosin periyttämällä valmiita rajapintoja. Esimerkiksi mallit perivät Active Model-rajapinnan, jotta niihin saadaan oikea toiminnallisuus, mutta jos kehittäjä haluaa täysin itsenäisiä luokkia, niin silloin luokkien ei tarvitse periä mitään. Tällöin niistä tosin katoaa valmista toiminnallisuutta, mutta myös rajoitteet katoavat. Katoavana rajoitteena esimerkiksi nimeäminen, joka vapautuu täysin kehittäjän päätettäväksi.

Kuvassa 7 olen merkannut kuvaan järjestelmän sisälle tummennettuna ne komponentit, joihin olen tehnyt itse muutoksia. Kuitenkin ':TranslationsController', ':views' ja ':Translation' ovat perittyjä jostain tai toteuttavat jonkun rajapinnan, jolloin niiden toiminnallisuus on suhteellisen rajoitettu ja ennalta määriteltyä. Ainoastaan ':TranslatorApi' on täysin itsenäinen oma staattinen luokkansa, jota ':Translation' käyttää hyväkseen muodostaessaan kyselyitä ulkopuoliseen Yandex-APIin. 

\subsection{Sekvenssikaavio}
Seuraavalla sivulla kuvataan sekvenssikaavion avulla miten uuden käännöksen tekeminen tapahtuu järjestelmässä ja miten se tallentuu tietokantaan. Kuvassa käyttäjä on navigoinut itsensä sivulle etusivulle ('/'-osoitteeseen). Hän kirjoittaa lomakkeeseen haluamansa tekstin, valitsee kielen ja painaa 'Translate!'-nappia (Kuva 1). Sekvenssikaavio alkaa tästä tapahtumasta, mutta siinä on abstrahoitu joitan osia pois (funktiokutsuja) pääosin sen takia, että kuvaa olisi helpompi tulkita.

On huomattavaa, että juuri kontrolleri luo instanssin Translation-mallista käyttäjän syöttämillä parametreilla ja hoitaa funktiokutsun ':TranslatorApi'-luokalle parametrinaan juuri luotu instanssi. Tässä tulee esille kontrollerin toiminta juuri tietovuon ohjaajana ja hallitsina, kun taas itse kääntäminen tapahtuu mallin kautta (Translation-mallilla julkinen translate-metodi). 

\begin{sidewaysfigure}
    \centering
    \includegraphics[width=1.05\textwidth]{images/sekvenssi.png}
    \caption{Sekvenssikaavio käännöksen tekemisestä ja tallentamisesta.}
    \label{fig:awesome_image}
\end{sidewaysfigure}

\newpage


\section{Kehyksen ja sovelluksen arviointi}

Sovelluskehyksenä Ruby on Rails on erittäin tarkka sen omista käytänneistä, kun sitä verrataan esimerkiksi toiseen erittäin suosittuun backend-sovelluskehykseen NodeJS:ään. NodeJS tarjoaa samalla tavalla kehyksen tuottaa web-palveluita, mutta se on rakenteellisesti paljon kevyempi ja vähemmän rajoittava. Toisaalta Ruby on Rails sopii hyvin aloitteleville ohjelmoijille sekä pienehköille start-up -henkisille yrityksille juuri sen käytänteiden vuoksi. Niitä noudattamalla pystytään todella nopeasti kehittämään palveluita asiakkaille samalla kaavalla.

Kuitenkin muutama heikkous kehyksessä nousee esille. Näitä ovat muun muassa suoritusteho, sovelluksen saaminen verkkoon, legacy-järjestelmän kanssa kommunikointi sekä sovelluskehyksen tuoma rajoittuneisuus \cite{rorad}.


\paragraph{Arkkitehtuurin sopivuus järjestelmälle}

Kehys ja kehyksestä johdettu MVC-mallinen arkkitehtuuri sopii todella hyvin tekemälleni järjestelmälle. Se on todella helposti muokattavissa sekä erilaisten näkymien/tietokannan vaihtaminen onnistuu hyvinkin nopeasti. 

Suurimmat laadulliset vaatimukset järjestelmälleni olivat alussa, että se on nopea saada pystyyn, nopeaa kehittää ja monipuolinen jatkon kannalta. Sovelluskehys tarjosi mielestäni nämä kaikki ja sivussa tuli muutama laatuvipukin. 

\subsection{Hyvät ja huonot puolet}

Hyvät puolet kehyksessä ovat selkeästi kehittämisen nopeus sekä konventioiden tuoma järjestelmien virtaviivaistaminen, kun taas huonot puolet tulevat suurimmalta osin konventioiden pakollisuudesta sekä Ruby-kielestä.

\subsubsection{Hyvät puolet}

Kehyksen hyvät puolet tulevat melkein automaattisesti noudattamalla jopa toisinaan tiukkoja Railsin konventioita. Hyviin puoliin lukeutuvat muun muassa konventioiden kautta tuleva REST-rajapinta; nopea kehitys, joka sopii hyvin Agile-projekteihin; konventiot itsessään, jotka auttavat kehittäjiä siirtymään helposti Rails projektien välillä; kielenä Rubyn itsedokumentoiva tyyli sekä useimmat kehykseen liitettävät ulkopuoliset kirjastot, jotka ovat suurimmalta osin avointa lähdekoodia \cite{bitzesty}.

Rails on tullut suosituksi myös startup-yrityksissä. Tähän on ollut syynä pääosin kehyksen: koventiot, kehys on käytännössä ilmainen kirjastoja myöten, erittäin hyvä PaaS-tuki (Platform as a Service), gem-ideologia (riippuvuudet yhdessä tiedostossa ja niiden helppo hallinta) sekä Rails on alustana kasvava ja reagoi uusiin tarpeisiin web-ympäristössä jatkuvasti \cite{wsuror}. 


\subsubsection{Huonot puolet}


\paragraph{Suoritustehon heikkous} 

Ruby on itsessään tulkattava kieli, joten suoritusteholtaan se häviää käännettäville kielille esimerkkinä Java Spring. Toisaalta Ruby on Rails -kehyksen teho tulee tuottavuuden nopeudesta, mutta tuottavuus ei ratkaise yhtä Railsin suurinta ongelmaa; erittäin huonoa tukea säikeistämiselle, joka johtuu Rubyn globaalista tulkitsemisen lukitsemisesta (global interpreter lock) \cite{mtmri}. Tämä tuottaa paljon ongelmia, jos järjestelmän yhtäaikaiset käyttäjämäärät kasvavat suuriksi, koska säikeistämisen avulla ei pystytä tasapainottamaan syntynyttä kuormaa (load balance). Täten Ruby on Rails soveltuu melko huonosti sovelluksille, jossa nopeus on oltava suuri myös silloin, kun käyttäjämäärät ovat suuria. Skaalautuuvus on myös tuottanut paljon puheita sekä puolesta, että vastaan \cite{rorsca}.

\paragraph{Sovelluksen vaikea tuotantoo saattaminen} 

Rails-kehys vaatii paljon esiasennusta, koska esimerkiksi tavallisissa Linux-jakeluissa ei edes ole Ruby-kirjastoa valmiina. Tämän päälle pitää asentaa itse kehys ja se vie suhteellisen paljon enemmän tilaa ja aikaa, kuin muut paljon kevyemmät kehykset \cite{bitzesty}. Tästä johtuu suhteellisen huono palvelimien tuki Ruby on Rails-kehykselle ja aikaa saa kulumaan palvelimen säätämisessä Railsia varten. 

\paragraph{Rajoittuneisuus}

Rails painottaa sisäisesti eleganttia syntaksia, tuotteliaisuutta sekä ylläpidettävyyttä nopeuden ja resurssien hallinan kustannuksella. Nämä on toteutettu suurimallta osin konventioiden avulla, joten kehys saattaa tuntua kehittäjille todella rajoittavalta. Vaikka konventioista voi poiketa, niin jokainen poikkeama mahdollistaa potentiaalisen virheen myöhemmin järjestelmän elinkaaressa. Konventiot myös rajoittavat legacy-järjestelmien kanssa toimimista ja varsinkin legacy-tietokannan kanssa työskentely vaatii kehyksessä jopa todella paljon konfigurointia \cite{rorlegacy}.



\subsection{Arviointi}

Kehystä arvioidessa keskitytään tässä raportissa kahteen laadulliseen tekijään: muunneltavuus sekä uudellenkäytettävyys. Nämä ovat myös tekijöitä, jotka tulevat esille melkein jatkuvasti Ruby on Rails-kehyksessä ja tuntuu, että ne ovat myös asioita joita kehys haluaa korostaa. Tarkastelussa kuitenkin huomataan tiettyjä riskejä, joita kehyksen käyttö ja nykyiset arkkitehtuuriset ratkaisut tuovat mukanaan. 


\paragraph{Laatupuu}
Muodostetut laatuskenaariot ovat luotu laatupuun avulla. Osa niistä on valittu  mittaamaan järjestelmän riskialttiita kohtia, kun taas osa on todella yleisiä tapauksia, joita saattaa tulla eteen kehyksen käytössä.


\begin{figure}[H]
\begin{center}
\fbox{\includegraphics[width=1\textwidth]{images/laatupuu.png}}
\caption{Skenaariot sijaitsevat oikealla ja jokainen on arvioitu niin, että ensimmäisenä on suluissa skenaarion vaativuus ja sen jälkeen arvioitu työmäärä. L = Low, M = Medium, H = High.}
\end{center}
\end{figure}


\subsubsection{Muodostettujen skenaarioiden analysointi}

\paragraph{Web-näkymä moderniksi single-page -sivustoksi}
Näkymän vaihtaminen on kehyksessä todella helppoa kuten aiemmin on mainittu, mutta vain jos näkymän rakenne noudattelee perinteisempää web-sivustoa. Nykyaikaisen yhden sivun näkymän tekeminen vaatii paljon Javascript-yhteensopivuutta ja kehykseltä standardisointia JSON-rajapinnoille \cite{rorspi}. Tätä kuitenkin hankaloittaa hieman Rails-kehys ja sen vahva MVC-patterni. Kuitenkin tähänkin ongelmaan löytyy valmiiksi ulkoinen kirjasto (gem), jonka avulla ongelma saadaan ratkaistua. Tästä syystä skenaarion vaativuus on matala, mutta sen toteutuminen vaatii kuitenkin ylimääräistä työtä. 

\paragraph{Vaihtaminen Unixista Windowsiin}
Skenaario saattaa tulla eteen jo esimerkiksi silloin, kun projektissa on yksi kehittäjä, joka käyttää Windows-käyttöjärjestelmää. Jotta kehittäjä pystyisi jatkamaan projektia, niin tarvitaan todella suuri määrä konfigurointia projektiin Windowsia varten, koska suurin osa Rails-kirjastoista on tehty Unix-järjestelmää varten. Tämä johtaa siihen, että harva ulkoinen kirjasto toimii enää ja jos projekti käyttää paljon ulkoisia kirjastoja, niin melkein jokaiselle on löydettävä vaihtoehto Windowsia varten. Tämä tuottaa todella paljon ylimääräistä työtä ja sen takia tälle skenaariolle on annettu korkeimmat mahdolliset arviot.

\paragraph{Kannan vaihtaminen SQLitestä MySQL:ään}
Tietokannan vaihtaminen onnistuu Rails-kehyksellä jopa vain muutamalla komennolla \cite{soror}, mutta vain jos vanha kanta on seurannut kehyksen konventioita. Kehys on varautunut toimimaan useilla eri relaatiotietokannoilla, mutta esimerkiksi dokumenttikannat vaativat jo ulkoisia kirjastoja. Kuitenkin SQLite on hyvin lähellä MySQL-tietokantaa, joten vaihtaminen onnistuu erittäin kivuttomasti. Vaihtoa helpottaa myös aiemmin mainittu ActiveDirectory-patterni, joten kannan vaihto ei vaadi yhtään ylimääräistä sisäistä konfigurointia esimerkiksi kyselyiden näkökulmasta. Tämän takia vaativuus on skenaariossa matala ja työmäärä keskitasoa. Työmäärä saattaa nousta juuri konventioista poikkeamalla. 

\paragraph{API:n luominen nykyisestä järjestelmästä}
Uudelleenkäytettävyyteen liittyvä skenaario on helppo toteuttaa Rails-kehyksestä, koska Rails tukee erittäin hyvin JSON-tietomuotoa sisäisesti. Pelkästään noudattamalla konventioita saa luotua automaattisesti JSON-rajapinnan järjestelmästään. Sitä muokkaamalla ja muutamalla ulkoisella kirjastolla saa luotua erittäin helposti API:n järjestelmää varten \cite{rorapi}. Suurin työ tulee pelkästään API:n suunnittelusta ja muusta kehyksen ulkopuolisesta työstä. 

\subsubsection{Skenaarioista johdetut päätelmät}

Suurin riski kehyksessä on alustan vaihtaminen, koska kehys on sidottu hyvin vahvasti siihen käyttöjärjestelmään, jolla järjestelmän kehitys on aloitettu. Tämä heikentää todella paljon muokattavuutta, koska esimerkiksi jos järjestelmä täytyy siirtää eri palvelimien välillä, niin on otettava erittäin tarkasti huomioon millä käyttöjärjestelmällä palvelin pyörii; varsinkin jos kyseessä on Windows. Tästä johtuvaa muunneltavuuden huonontumista voidaan estää muunmuassa kartoittamalla sovellusaluetta tarkasti, ottamalla etukäteen selvää ulkoisten kirjastojen tuista tai käyttämällä mahdollisimman vähän ulkoisia kirjastoja. 

Vahvaa MVC-patternia kehyksessä voidaan pitää herkkyyskohtana, koska niin moni kehyksen tarjoamista laadullisista ominaisuuksista perustuu tähän. Siitä poikkeaminen johtaa ongelmiin kehyksen konventioiden kanssa ja saattaa huonontaa merkittävästi järjestelmän yleistä muunneltavuutta. Konventioista luopuminen taas heikentää merkittävästi tätä laatuominaisuutta, mutta toisaalta konventiot voidaan laskea kuuluvan myös tasapainottelukohtaan, koska ne edistävät muunneltavuutta, mutta muunneltavuuden parantaminen heikentää suorituskykyä. Tästä esimerkkinä ActiveRecord joka luo joustavan rajapinnan tietokantaan, mutta, jonka muodostamat käskyt saattavat joskus olla hyvinkin suuria ja hitaita \cite{rorper}.

On kuitenkin huomattavaa, että kaikki muut skenaariot ovat arvioiltaan alhaisia, joten sovelluskehyksen käytöstä on erittäin paljon hyötyä, jos tietyt skenaariot ovat todennäköisiä järjestelmän elinkaaressa. Esimerkiksi tietokannan vaihtaminen saattaa tulla esille vasta myöhemmässä vaiheessa järjestelmän elinkaarta, jolloin sen vaihtaminen voi olla jollain muulla sovelluskehyksellä kallista ja hidasta. Ruby on Rails -kehyksellä se onnistuu erittäin nopeasti, mutta vain jos määriteltyjä konventioita on noudatettu jo aikaisemmankin tietokannan kanssa.






\newpage
\cleardoublepage
%
% Sitten alkaa lähdeluettelo
%


\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

\end{document}
